---
title: You don't know js 笔记
date: 2020-05-06 00:17:36
tags: 
  - JavaScript
---

## 基本概念

1.编程范式

在编程语言里语境里，一般指编程的一种观念或方法，用来组织代码。

用此，我们有了无数形式的来区分程序（代码）

包括无数不同的库或者框架也为此，给自己的代码，签上了自己的署名。这是特点也是卖点。

典型的编程范式种类包括：程序性的，面向对象的和函数式的。

- 程序性代码，从上到下依次执行。通过一系列预先定好的操作，通常整合在程序里面（相关的代码单元）
- 面向对象的代码通过classes 类来整理逻辑和数据，放入代码单元里。
- 函数式是将代码组织进函数（他很反对程序性的面条式的写法） ，然后把这些函数当成值来使用。

范式没有对错，都是指导程序员组织和维护代码，来解决问题的方法。有的语言倾向于一种编程范式，有的语言是多种编程范式的混合。JavaScript就是多范式的语言，几种情况可以任意选。

2.向前兼容&向后兼容

JavaScript的基本原则之一就是，保留向后兼容。

**向后兼容**：现在代码在当前版本里能用，在将来的JS版本里出现新的写法。老的写法依然能用。

这样对于开发者，选择JavaScript进行开发是一个明智和安全的投资，数年后，你的代码依然能够被运行，如果需要的话。

当然也有特例不能向后兼容，这是极少数情况，规范委员会会非常谨慎这样做，

**向前兼容**：当程序运行在旧的js引擎中的时候，如果当程序中的代码有新的语言特性，程序并不会崩溃，那就是向前兼容。

html 和 css 就是向前兼容的，讲2020最新的代码，放入2010的浏览器，依然能正常运行。反之不行。

只能向后兼容，我们就会面临一个问题，我的代码的语言特性必须被运行环境支持，不能使用最新的代码特性。

如果还是要使用新的不兼容的特性，还有有办法的。便是转译。babel便是最常用的转译工具之一。

3.polyfill

这个词多次听说，却不知具体作用。其实就是向前兼容不是关于新的语法格式，而是出现了一个新api方法（是旧语法规范所没有的）

这时就需要为这个缺失的api写一个定义，就像本地已经定义好了并可以运行的。

4.解析型语言

JavaScript是解析型的语言。可能由于编程的历史原因，想对于编译型，人们不太赞成他。造成这种刻板印象有几个原因：缺少性能优化；甚至不喜欢语言本身的特性如总是使用动态类型，而不是使用成熟的静态类型。（现在有ts辅助，js的类型也不是限制开发的问题，后话了）

一般编译型语言都会事先生成一份可携带的二进制文件，供后面执行。虽然分发js的源码，而不是二进制编码。但毕竟没有编译成二进制的机制。这些年来，分发二进制可执行文件的模式已经不重要了。这些错误的成见可以放在一边。

真正关键的问题是：js 是解析型的还是编译型的，在于他是如何处理错误的。

解析型的语言是从上到下执行，到错误的地方才停止运行（指解析）。

JavaScript代码的执行过程：

- 在离开开发者的编辑器之后，被babel编译，被webpack打包甚至还有其他一系列的构建过程。然后被送往不同的js 引擎环境。
- JS引擎将 代码解析成抽象的格式树，abstract syntax tree(AST)
- 然后引擎将ast装换成一种字节码（一种二进制中间过渡体），再被JIT编译器优化。
- 最后，被js vm 执行。（virtual machine）



其实如果不是操作上的原因，其实js 也有编译的过程。

5.关于开发者工具

初一看是个简单直接的js运行环境，实际上不是。只有有很多巧合让人误以为developer tools 是js 引擎。

6.关于严格模式

   从es5开始，js 添加了strict mode 作为内部可选机制。

   他存在的目的是为了更加规范人们的写法。毕竟这么做的收益大于成本。但由于历史原因，10年来，没有很好的应用，人们还会用一些老的写法。

严格模式下的代码能本js 引擎更好的优化和运行。



## js 一些特性

1.每个文件都是一个程序。

虽然我们往往会认为整个应用才是一个程序。JS里面每个文件都可做为独立的程序。

这一点很重要，关系到js的错误处理机制。既然每个文件都是一个程序，那么一个文件在解析、编译或者执行的时候就可以出错，也就没有必要阻止下一个文件的处理。这样应可应用还是可以部分运行的。

多个单独js文件为什么能像单个应用一样运行？靠的就是global scop（全局作用域）。只要所有独立运行的js文件，在这全局作用域的命名空间下，在运行时（一种具备js处理能力的工作环境）就能表现为一个整体。

相对于js的单文件程序格式，es6又引入了模块化的格式。模块化格式也是基于文件的，只要一个文件是通过模块加载机制如：

- import 声明
- `<script type=module>`标签

那么所有的代码会当作一整个模块。

对于模块的处理，他也是像处理单个文件一样，可以独立处理单个模块。类似于全局作用域允许单个文件在运行时下一起工作，讲一个模块导入其他模块，也允许运行时交互运行不同的模块。

## values

程序中最小的信息单元就是'变量'，变量就是数据。用来给程序保存状态。这些变量来自两种类型：原始值和对象。

### 原始类型

原始字面量字符串："My name is Kyle."

- 字符串是字母的有序集合。通常用来代表单词或者句子。
- 可一用单引号，也可用双引用。只是一个文体风格不同。
- 如果用了 ` 就是模板字符串了。此时字符串里可插入变量。

boolean 和number 是另外两种原始值。

和前三者不同的原始值还有两个 null 和undefined。看上去似乎都是表示值的缺失，其实还是有区别的。

更安全更好的做法 是只使用 undefined来表示一个缺省的值。

最后一个原始值是symbol：通常用来表示一个独一无二的值。通常用来表示对象的key值。（对象的key值是不能重复的）

### 对象类型

对象类型包括array 和 object。

数组是特殊的对象，由一个有序的、带数字索引的数据列表组成。

JS 的数组能接住任何的变量类型。除了原始类型和对象类型，连函数值也能存入数组。

对象更为普遍：一个无序的，有键值的变量的集合。换句话说，你可以通过一个字符串定位名（亦称 键key和属性property) 而不是他的数字位置来获取一个元素。

### 变量类型的判断

我们使用typeof操作符，可判断变量的内置类型。

```javascript
typeof 42;                  // "number"
typeof "abc";               // "string"
typeof true;                // "boolean"
typeof undefined;           // "undefined"
typeof null;                // "object" -- oops, bug!
typeof { "a": 1 };          // "object"
typeof [1,2,3];             // "object"
typeof function hello(){};  // "function"
```

### 声明和使用变量

变量是值的容器。先有容器才能存东西。所以先声明变量才能存放值。

声明变量的标识符：var 和 let。

let 声明的变量会受到一些限制相比var。这种限制的访问，叫做"块级作用域"，相比于正常的或函数作用域。

```JavaScript
var adult = true;

if (adult) {
    var myName = "Kyle";
    let age = 39;
    console.log("Shhh, this is a secret!");
}

console.log(myName);
// Kyle

console.log(age);
// Error!
```

块级作用域非常有用，对于控制程序中大量变量有帮助，防止变量名的重叠。

使用var 也很有用，因为它表达了：这个变量将在更宽泛的作用域（对于整个函数）内使用。

根据代码条件，两种声明方式都是可以在给定程序的任何部分使用的。

注意：有一条非常普遍的建议是：避免使用aviod 而是使用let 或者 const。通常是因为var的作用域行为在js代码运行前就已经开始工作了。这似乎限制过头了，而且极其没有帮助。他这么说就已经假定了你不能在多个特性共同组合下，使用某个特性。我们能够也应该学会任何特性，并合适的地方使用他们。

第三中声明形式是` const ` ，跟let类似有额外的限制：在声明的时候需要同时（立即）给个值，而且之后不能被重新赋予不同的值。

```javascript
const myBirthday = true;
let age = 39;

if (myBirthday) {
    age = age + 1;    // OK!
    myBirthday = false;  // Error!
}
```

除了var/let/const，还有其他的句法的声明形式，在不同的作用域中。比如：

```javascript
function hello(myName) {
    console.log(`Hello, ${ myName }.`);
}

hello("Kyle");
// Hello, Kyle.
```

### 函数 Functions

function在编程中有多种不同的含义。

在函数式编程中，函数有明确的数学定义，明确了一些需要严格遵守的规则。

在JS中，我们考虑函数"function" 采用更宽泛的含义相对于另一个相关的术语：procedure（程序）。一个程序是一系列声明的集合，可以被引用一次或者多次，可以提供一些输入，可以给出一个或者更多个输出。

早起的函数定义：

```
function awesomeFunction(coolThings) {
    // ..
    return amazingStuff;
}
```

采用的是函数声明 的形式。不是采用表达式或者在其他的声明当中。标识符awesomeFunction 和函数值之间的关联，是在代码编译的时候，在代码执行之前就出来了。

相对于函数声明式，函数表达式可如下定义并指派：

```javascript
// let awesomeFunction = ..
// const awesomeFunction = ..
var awesomeFunction = function(coolThings) {
    // ..
    return amazingStuff;
};
```

不同于函数声明式，函数表达的式没有和标识符关联起来，知道它的声明在运行时中运行。

在JS这一点极其重要：函数也是一种值，可以被分配和传递。事实上，js函数是一种特殊的对象值类型。不是所有语言把函数当作值的，但这对于一门语言要支持函数式编程尤其重要，正如js所做的。

## 类classes

面向对象和面向类是我们常听到的术语，但有很多细节而且有细微差别的。

我们在这里使用更传统的定义，有C++或者java这样面向对象语言背景的同学可能会更熟悉这些。

> 程序中的类class是一种用户数据结构的定义。这种数据结构包括数据和操作数据的行为。
>
> classes定义这样的数据结构如何工作，但是classes本身不是具体的值，为了得到一个具体的值以便在程序中使用，一个类class必须用new 关键字实例化一次或者多次。

除了属性可以继承，方法也可以继承。继承和被继承的方法可以取同样的名字，并可以共存，这就叫做多态。

## 模块modules

模块的模式本质上和类的模式有同样的目标--在一个逻辑单元里组织数据和行为。也像类一样，模块能够分发自己或取用其他模块的数据或者行为，出于协同的目的。

但是模块和类有一些非常重要的区别。尤其是他们的句法是完全不同的。

### 一、classic Modules

经典的模块。早期js中，模块和公共样式在无数的js程序中使用，甚至还没有一个统一的标准格式。

经典模块的核心特点是：一个外部函数（至少运行一次），他会返回实例，这个实例带有一个或者更多个暴露出来的函数。这些函数可以操纵模块实例内部隐藏的数据。

但是因为这样的模块只是一个函数，只要引用他就会产生一个模块的实例，另为一个叫法可以描述这些函数-- 模块工厂。



### 二、ES Modules

是在es6版本引入到js语言的模块。他也是出于同样的精神，考虑到已经存在的类模块，尤其考虑到了amd umd 和commonJS的重要差异以及使用案例。

他的实现方法当然完全不同。

1.没有使用外包的函数来定义一个模块。外包的上下文是整个文件。ESM一直是基于文件的，一个文件一个模块。

2.你没有和模块api交互，而是使用export关键字，来添加一个变量或者方法到他的公共api定义上去。如果一些内容定义在一个模块上，但是没有导出，那他就是隐藏的。（就想古典模块一样）

3.可能是和先前讨论模式最明显的一个不同。你不需要实例化一个ES 模块，你只是import 引入他，来使用他的 单例（single module).

ESMs模块都是单例的，意味着一经创建只有一个实例。如果你想要支持多例模式，在你的esm模块定义时，你不得不提供一个经典模块的工厂函数。